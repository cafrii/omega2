'''
13910번
개업

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
1 초	256 MB	2531	799	614	31.471%

문제
해빈이는 짜장면을 정말 좋아한다. 짜장면을 너무 좋아한 나머지 짜장면만 파는 중국집을 개업했다!
해빈이는 양손잡이여서 동시에 두 개의 웍(중국 냄비)을 사용하여 요리할 수 있다.
그러나 해빈이는 낭비를 매우 싫어하기 때문에 요리 할 때, 필요 이상 크기의 웍을 사용하지 않으며,
주문 받은 짜장면의 그릇 수에 딱 맞게 요리한다.

<웍>

예를 들어 짜장면 4그릇을 주문 받았는데 5그릇 이상을 요리하지 않으며,
4그릇을 요리할 수 있는 웍에 3그릇 이하의 요리를 하지 않는다.

해빈이가 5그릇을 주문 받았고, 해빈이가 가지고 있는 웍의 종류가 1, 3그릇 용이라면
처음에 1,3그릇용 웍을 동시에 이용하여 4그릇을 만들고
다음 1그릇용 웍을 이용하여 1그릇을 만들어 총 5그릇을 두 번의 요리로 만들 수 있다.

해빈이가 주문 받은 짜장면의 수와 가지고 있는 웍의 크기가 주어질 때,
최소 몇 번의 요리로 모든 주문을 처리할 수 있는지 출력하는 프로그램을 작성하시오.

입력
첫 번째 줄에는 해빈이가 주문 받은 짜장면의 수 N(1≤N≤10,000)과
가지고 있는 웍의 개수 M(1≤M≤100)이 주어진다.
두 번째 줄에는 웍의 크기 Si(1≤Si≤N)이 M개가 주어지며 같은 크기의 웍을 여러 개 가지고 있을 수 있다.

출력
해빈이가 모든 주문을 처리하기 위해 해야 하는 최소 요리 횟수를 출력한다.
만약 모든 주문을 처리 할 수 없는 경우 -1을 출력한다.

------


배낭 문제로 접근 시도.

웍의 크기: 물건의 무게
식사해야 할 인원: 배낭의 크기
? : 물건의 값어치

정확하게 배낭을 가득 채워야 함. 넘쳐도 안되고, 부족해도 안됨.
=> 분할 불가능한 배낭 문제, 즉 0-1 배낭 문제와 유사.

담을 수 있는 물건의 종류(웍의 크기)는 정해져 있음. 크기가 동일한 웍이 여러개일 수도 있음.
반면 물건의 개수는 제약 없음. (웍을 여러번 사용할 수 있음.)

문제의 목적이 다름.
배낭 문제는 값어치를 최대로 하는 것이 목표이지만, 여기서는 물건의 개수를 최소화.

일단 양손잡이 조건을 무시하고 한번 풀어보도록 하자.

0-1 배낭 문제의 경우, 원래 조건 찾기가 어려움. 따라서 N을 하나씩 늘려가며 모든 경우를 다 확인해 가야 함.

dp[k]: k 인분 식사 준비 최소 회수
= min(
    # 모든 가능한 웍에 대해서.. a, b, c, ..
    dp[k-a] + 1, # a 인분 웍 사용
    dp[k-b] + 1, # b 인분 웍 사용
    ...
  )
이런 식으로 가능해 보임.

이제 양손 고려.
dp[k]: k 인분 식사 준비 최소 회수
= min(
    # 하나의 웍만 사용하는 경우: 모든 가능한 웍에 대해서.. a, b, c, ..
    dp[k-a] + 1, # a 인분 웍 사용
    dp[k-b] + 1, # b 인분 웍 사용
    ...
    # 두 개의 웍을 사용하는 경우: (a1,a2), (b1,b2), ... 웍의 종류가 너무 많은데?
    # 중요한 것은 (a1+a2), (b1+b2), .. 즉 두 웍의 합이니까, 어차피 최대 200가지 밖에 안된다.
    dp[k-a1-a2] + 1, # a1, a2 인분 웍 사용
    dp[k-b1-b2] + 1, # b1, b2 인분 웍 사용
    ...
  )

------
양손 고려하는 경우를 하나의 try가 되도록 합쳐서 계산하면 단순화 됨.

최적화 1:
양손 고려가 완료된 이후에는, 동일한 wok size가 여러개 있더라도 의미 없으니 set 로 중복 제거.
예:  2, 4 크기 wok 양손 요리나 1, 5 양손 요리는 차이 없음. 또한 6 한손 요리 도 마찬가지.


최적화 2:
dp 가 아니라 bfs 로 풀 경우 더 빠른 시간 달성함!

98104629 cafrii  13910  맞았습니다!! 34992KB   928ms Python 3  1276B    <- bfs
98102455 cafrii  13910  맞았습니다!! 32412KB  2040ms Python 3  1008B    <- dp

test case 문제가 어떤 것인지는 모르겠는데, 내가 시뮬레이션 테스트 할 때 보다 시간이 꽤 오래 걸림.
내 tc 로는 수십 밀리초 밖에 안되는데..


'''



import sys

def log(fmt, *args): print(fmt % args, file=sys.stderr)

def get_input():
    input = sys.stdin.readline
    N,M = map(int, input().split())
    W = list(map(int, input().split())) # wok sizes
    assert len(W) == M, "wrong wok num"
    return N,W


def solve_dp(N:int, W:list[int])->int:
    '''
    Args
        N: target num to compose. <= 10_000
        W: list of wok sizes. len <= 100, 1<=w<=N
    '''
    ws = set(W) # wok size set. 단독 사용

    # 웍 두개 조합 사용. 총합 만 중요.
    for j in range(1, len(W)):
        for i in range(j):
            ws.add(W[i]+W[j])

    INF = max(10_001, N+1)
    dp = [ INF ] * (N+1)
    dp[0] = 0

    for k in range(1, N+1):
        # dp[k]: k 인분 식사 준비 최소 회수
        for w in ws:
            if w <= k:
                dp[k] = min(dp[k], dp[k-w]+1)

    return dp[N] if dp[N] < INF else -1


if __name__ == '__main__':
    print(solve_dp(*get_input()))







'''
예제 입력 1
5 2
1 3
예제 출력 1
2

예제 입력 2
6 2
1 3
예제 출력 2
2

-----
run=(python3 13910.py)

echo '5 2\n1 3' | $run
# 2

echo '6 2\n1 3' | $run
# 2

echo '10 1\n7' | $run
# -1

echo '10 2\n8 3' | $run
# -1

echo '10 2\n8 1' | $run
# 2



------
시간초과 시뮬레이션


(python3 <<EOF
import time
from random import seed,randint
seed(time.time())
#seed(43)
N,M = 10_000,100
# w = [1] * M
w = [ randint(1,max(10,N//100)) for k in range(M) ]
print(N,M)
print(' '.join(map(str, w)))

EOF
) | time $run
# list 구현
# 556,  $run  3.08s user 0.01s system 99% cpu 3.102 total
# set 로 구현하면 무시할 수 없을 정도로 작음.



'''

