'''
1660번
캡틴 이다솜, 골드5

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
2 초	128 MB	7530	2837	2087	37.301%

문제
캡틴 이다솜은 자신의 해적선에 적을 공격하기 위한 대포알을 많이 보관해 놓는다.
다솜이는 미적감각이 뛰어나기 때문에, 대포알은 반드시 사면체 모양으로 쌓아놓아야 한다고 생각한다.
사면체를 만드는 방법은 길이가 N인 정삼각형 모양을 만든다.
그 위에 길이가 N-1인 정삼각형 모양을 얹고 그위에 계속 해서 얹어서 1크기의 정삼각형 모양을 얹으면 된다.

예를 들어, 사이즈가 3크기의 한 더미 모양은 다음과 같다.

  X

  X
 X X

  X
 X X
X X X

각각의 삼각형은 1, 3, 6, 10 ,..... 와 같이 대포알을 가지고 있다.
따라서 완벽하게 쌓았을 때, 한 사면체에는 1, 4, 10, 20 ,.... 개를 가지고 있을 것이다.

현재 다솜이의 해적선에 대포알이 N개가 있다.
다솜이는 영식이를 시켜서 사면체를 만들게 하고 싶다.
영식이는 물론 하기 싫지만 어쩔수 없이 다솜이가 시키는대로 사면체를 가능한 최소 개수 만큼 만들려고 한다.
N개의 대포알로 만들 수 있는 사면체의 최소 개수를 출력하는 프로그램을 작성하시오.

입력
첫째 줄에 입력 N이 들어온다. N은 300,000보다 작거나 같은 자연수이다.

출력
첫째 줄에 영식이가 만들 수 있는 사면체 개수의 최솟값을 출력한다.

----

2025/9/12, 8:56~9:29

----

훨씬 더 빠르게 수행하는 구현이 존재한다. 개선 검토해 보자!

97897762  3veryday   1660  맞았습니다!!  32412   424ms  Python 3  682B  <-- 훨씬 더 빠름.
98822004  cafrii     1660  맞았습니다!!  44992  2740ms  Python 3  1448B

----


'''



import sys

def log(fmt, *args): print(fmt % args, file=sys.stderr)

def get_input():
    input = sys.stdin.readline
    N = int(input().rstrip())
    return N,

def solve(N:int)->int:
    '''
    Args: N: number of balls
    Returns: minimum number of tri-pyramid to compose

    만들 수 있는 사면체의 최소 수는 가능한 한 큰 사면체를 만들려고 시도하는 것이 쉽다.
    즉, greedy 접근.
    문제는 과연 이게 최적의 방법인가? 더 적은 수로 만들 수 있는 것이 아닌가?

    완전한 사면체에 필요한 볼 수
        1
        3+1 = 4
        6+3+1 = 6+4 = 10
        10+6+3+1 = 10+10 = 20
        15+.. = 15+20 = 35
        21+35 = 56
        ...
    맨 앞의 수, 즉 바닥층의 볼 개수는 규칙을 찾을 수 있다.
    맨 바닥층의 볼 수 (h 층인 경우): 1부터 h까지의 합 (h+1)*h/2

    그리고 그 위에 쌓을 수 있는 볼 수는 그 직전의 바닥층 수와 같다.
    즉, h-1 층 사면체의 바닥층 볼 수: h*(h-1)/2

    그러면 h층 사면체를 구성하는 총 볼 수를 X(h) 라고 하면
    X(h) - X(h-1) = (h+1)*h/2

    그다음은 잘 모르겠음.

    greedy 대신 dp를 바로 적용하자.
    bottom up, forward, layered.

    '''
    MAX_N = 300_000
    # max_height = sqrt(MAX_N*2)

    dp = list(range(N+1))  # [0, 1, 2, .., N]
    # dp[k] 는 볼 개수 k로 사면체를 만들 수 있는 사면체의 최소 개수
    # 처음에는 1층 짜리 (볼 1개짜리 사면체) 로만 만드는 경우로 초기화
    # log("dp: %s", dp)

    j = 0
    for h in range(1, MAX_N):  # 몇 층 까지 할 수 있을지 알 수 없으니 충분히 큰 수로..
        # h: 사면체의 높이. 1, 2, 3...

        b = (h+1)*h//2
        # b: 높이 h 사면체의 바닥층의 볼 수:  (h+1) x h / 2
        #  1, 3, 6, 10, 15, 21, ..

        j += b
        # j: 높이 h의 사면체의 전체 볼 수. 직전 h-1 높이 사면체 볼 수 (j) 에 바닥층 볼 수 (b) 추가
        #  1, 4, 10, 20, 35, 56, ..

        if j > N: break
        # 어느 h 이상이 되면, 보유한 볼 수로는 만들 수 없게 됨.

        for k in range(j, N+1):
            dp[k] = min(dp[k], dp[k-j]+1)

        # log("h %2d, j %3d, dp: %s", h, j, dp)

    return dp[N]


if __name__ == '__main__':
    print(solve(*get_input()))




'''
예제 입력 1
15
예제 출력 1
3
예제 입력 2
1
예제 출력 2
1
예제 입력 3
5
예제 출력 3
2
예제 입력 4
9
예제 출력 4
3
예제 입력 5
91
예제 출력 5
2
---

run=(python3 a1660.py)

echo '15' | $run
# 3
echo '1' | $run
# 1
echo '5' | $run
# 2
echo '9' | $run
# 3
echo '91' | $run
# 2


echo '300000' | time $run
# 3
# $run  1.53s user 0.01s system 99% cpu 1.546 total
# 시간이 다행히 조건 이내이다.


'''


