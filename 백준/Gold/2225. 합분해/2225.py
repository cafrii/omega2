
'''
2225번

합분해 성공

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
2 초	128 MB	52791	24270	18060	44.614%

문제

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

입력
첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

출력
첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

-------

11:35~55 문제 이해 파악 완료
12:40 제출 완료. 1시간이나 걸렸네. 최적화 하느라 시간 소비했음.

-------
문제: N=5 K=3 인 경우.

N=5, K=2 의 결과에 0 을 추가
5 0 0
4 1 0
3 2 0
2 3 0
1 4 0
0 5 0

N=4, K=2 의 결과에 1을 추가
4 0 1
3 1 1
2 2 1
1 3 1
0 4 1

N=3, K=2 의 결과에 2를 추가
3 0 2
2 1 2
1 2 2
0 3 2

N=2, K=2 에 3 추가
2 0 3
1 1 3
0 2 3

N=1, K=2 에 4 추가
1 0 4
0 1 4

N=0, K=2 에 5 추가
0 0 5


 K 1  2  3
N ---------
0  1  1  1
1  1  2  3
2  1  3  6
3  1  4 10
....


'''



import sys
input = sys.stdin.readline

def log(fmt, *args): print(fmt % args, file=sys.stderr)

MOD = 1_000_000_000

def solve(N, K):

    dp = [ [ 0 for n in range(N+1) ] for k in range(K+1) ]
    # dp[k][n] 는 N=n, K=k 일때의 답.
    # dp[0] 은 의미 없음.

    # dp[1] 은 특정 N을 만드는 경우는 1가지씩 밖에 없음.
    # dp[1][0] 부터 dp[1][N] 까지 존재함.

    dp[1] = [ 1 ] * (N+1)
    # log("dp[%d]: %s", 1, dp[1])

    '''
        dp[K] 는 이전 계산들 중 K-1 로 이루어진 값들을 재활용해야 한다.
        dp[K][N] = (
            dp[K-1][N] + # 끝에 0 을 더하는 경우
            dp[K-1][N-1] +  # 끝에 1 을 더하는 경우
            dp[K-1][N-2] +  # 끝에 2 을 더하는 경우
            ...
            dp[K-1][1] +
            dp[K-1][0]
        )
        그런데 이는 앞의 계산식을 다시 재활용할 수 있다.
        dp[K][N-1] = (
            dp[K-1][N-2] +  # 끝에 1 을 더하는 경우
            ...
            dp[K-1][0]
        )
        따라서..
        dp[K][N] = dp[K][N-1] + dp[K-1][N]

        dp[K][N]을 구하려면 k<=K, n<=N 인 모든 k,n 에 대해서 미리 계산이 되어 있어야 한다.
        (k 는 1 부터 K 까지, n 은 0 부터 N 까지.)

    '''

    for k in range(2, K+1):
        dp[k][0] = 1
        for n in range(1, N+1): # n: 1 ~ N
            dp[k][n] = (dp[k][n-1] + dp[k-1][n]) % MOD

        # log("dp[%d]: %s", k, dp[k])

    return dp[K][N]


N, K = map(int, input().split())
print(solve(N, K))



'''
예제 입력 1
20 2
예제 출력 1
21

예제 입력 2
6 4
예제 출력 2
84


1 5
-> 1

1 1
-> 1

134 23
-> 812741700

50 6
-> 3478761

117 23
-> 522390800

87 65
-> 522380750

200 200
-> 753387060

'''
