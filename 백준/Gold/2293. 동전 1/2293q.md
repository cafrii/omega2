# 질문

1차원 dp로 푸는 방법에서 궁금한점이 있다.
나도 이 방법을 생각해 보다가 중간에 포기한 이유는 바로 중복의 가능성 때문이었다.
다음 메모를 참고하라.

```
1, 2, 5 로 10을 만드는 경우의 수.

10을 만드는 경우의 수 = 9를 만드는 경우의 수 (여기에 1만 더하면 10이 되므로) + 8을 만드는 경우의 수 + 5를 만드는 경우의 수

하지만 이 방법은 중복 제거가 불가능해 보임.

9를 만드는 경우들에 1원을 더하는 것의 집합, 8을 만드는 경우들에 2원을 더하는 것의 집합

이 두 집합이 서로 소 인가?
```
자, 어떻게 중복 문제를 해소할 수 있는가?


# 답변

아주 좋은 질문입니다! 중복 문제에 대한 우려는 정당합니다. 하지만 1차원 DP 방식에서는 **동전의 순서를 고정**함으로써 중복을 자동으로 방지합니다.

## 중복이 발생하지 않는 이유

### 핵심: 동전을 **순서대로** 처리

```
동전: [1, 2, 5] 순서로 처리

1단계: 1원 동전만 사용
dp[0] = 1
dp[1] = dp[0] = 1  (1)
dp[2] = dp[1] = 1  (1+1)
dp[3] = dp[2] = 1  (1+1+1)
dp[4] = dp[3] = 1  (1+1+1+1)
dp[5] = dp[4] = 1  (1+1+1+1+1)
...

2단계: 2원 동전 추가
dp[2] += dp[0] = 1+1 = 2  (기존: 1+1, 새로: 2)
dp[3] += dp[1] = 1+1 = 2  (기존: 1+1+1, 새로: 1+2)
dp[4] += dp[2] = 1+2 = 3  (기존: 1+1+1+1, 새로: 1+1+2, 2+2)
dp[5] += dp[3] = 1+2 = 3  (기존: 1+1+1+1+1, 새로: 1+1+1+2, 1+2+2)
...

3단계: 5원 동전 추가
dp[5] += dp[0] = 3+1 = 4  (기존: 1+1+1+1+1, 1+1+1+2, 1+2+2, 새로: 5)
...
```

### 왜 중복이 발생하지 않는가?

**각 동전을 처리할 때마다, 그 동전을 "마지막에 추가"하는 경우만 고려**하기 때문입니다.

- 1원 동전 처리: 1원으로 끝나는 조합들만 생성
- 2원 동전 처리: 2원으로 끝나는 조합들만 생성
- 5원 동전 처리: 5원으로 끝나는 조합들만 생성

### 구체적인 예시로 확인

10원을 만드는 경우:
- **1로 끝나는 경우**: 9원 + 1원 (9원을 만드는 모든 방법에 1원 추가)
- **2로 끝나는 경우**: 8원 + 2원 (8원을 만드는 모든 방법에 2원 추가)
- **5로 끝나는 경우**: 5원 + 5원 (5원을 만드는 모든 방법에 5원 추가)

이 세 집합은 **서로소**입니다! 왜냐하면 각각 다른 동전으로 끝나기 때문입니다.

## 수학적 증명

만약 중복이 있다면, 어떤 조합이 두 번 이상 세어져야 합니다. 하지만:
- 1로 끝나는 조합은 2나 5로 끝날 수 없음
- 2로 끝나는 조합은 1이나 5로 끝날 수 없음
- 5로 끝나는 조합은 1이나 2로 끝날 수 없음

따라서 중복이 발생할 수 없습니다.

이 방식이 정확히 동전의 순서를 고정하여 중복을 방지하는 핵심 아이디어입니다. 혹시 더 궁금한 점이 있으시면 말씀해 주세요!

