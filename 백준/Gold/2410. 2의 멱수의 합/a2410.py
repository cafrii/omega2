'''
2410번
2의 멱수의 합 다국어, 골드5

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
2 초	128 MB	6388	2662	2073	42.427%

문제
어떤 자연수 N을 2의 멱수의 합으로 나타내는 경우의 수를 구하는 프로그램을 작성하시오.
2의 멱수라는 것은, 2^k으로 표현되는 자연수를 의미한다.

예를 들어 7을 2의 멱수의 합으로 나타내는 경우의 수는 다음의 여섯 가지가 있다.

1+1+1+1+1+1+1
1+1+1+1+1+2
1+1+1+2+2
1+1+1+4
1+2+2+2
1+2+4

입력
첫째 줄에 N(1 ≤ N ≤ 1,000,000)이 주어진다.

출력
첫째 줄에 경우의 수를 출력한다. 답이 커질 수 있으므로 1,000,000,000으로 나눈 나머지를 출력한다.

----

2025/9/13, 5:00~

----
2의 멱수: 2^k 로 표현되는 자연수. (1, 2, 4, 8, 16, 32, ..)
자연수 N을 2의 멱수의 합으로 나타내는 경우의 수

Coins 문제랑 아주 유사하다. 각 멱수가 동전이라고 생각할 수 있다.
- 각 유형 별 사용할 수 있는 회수 제한은 없다. 즉, 배낭 문제랑은 다르다.
- 순열이 아니라 조합이다. 즉, 1+1+2 랑 2+1+1 은 동일한 하나로 카운트 한다.
- 정확한 goal 값을 만들어야 한다.

그런데 만들어야 하는 goal 최대가 좀 크다. max N = 1,000,000 ~ 1M
이러면 시간이 아주 많이 걸릴 수 있다.
다행히 멱수의 종류 (동전 유형의 수)는 그리 많지 않을 것임. 2^20 정도이니 20개 내외임.


----
    dp = [ 0 ] * (N+1)

    dp[0] = 1
    dp[1] = 1  # 1,
    dp[2] = sum([
        dp[1], # 1+1
        dp[0], # 2
    ]) # == 2
    dp[3] = sum([
        dp[2], # 1+1+1, 2+1,
        dp[1], # 1+2
        # 여기서 문제. 2+1 과 1+2 는 결국 한가지.
    ]) # != 3, == 2

    이 문제를 해결하려면, 동전을 반드시 "순서대로" 사용하도록 강제해야 한다.
    작은 수 부터 사용하도록 강제한다면, dp[2] 에서 2+1 같은 경우는 카운트 되지 않을 것이다.
----

Hint
작은 수들(1, 2, 3, 4, 5, 6, 7...)을 직접 계산
패턴을 찾아보자.


1 1      1
2 2  <-  1+1 2
3 2      1+1+1 2+1
4 4  <-  1+1+1+1 2+1+1 / 2+2 4
6 6
8 10  <- 1x8 1x7+2 1x4+2+2 1x4+4 1+1+2+1+1+2 1+1+2+2+2 1+1+2+4 2+2+2+2 2+2+4 4+4 8
10 14
12 20
14 26
16 36
18 46
20 60


----
dp[n]과 dp[n//2]의 관계

dp[0]  =  1,  dp[0]  =  1
dp[2]  =  2,  dp[4]  =  4
dp[4]  =  4,  dp[8]  = 10
dp[6]  =  6,  dp[12] = 20
dp[8]  = 10,  dp[16] = 36
dp[10] = 14,  dp[20] = 60
dp[12] = 20,  dp[24] = 94
dp[14] = 26,  dp[28] = 140
dp[16] = 36,  dp[32] = 202

dp[8] = dp[4] + dp[4] + dp[2]
dp[12] = dp[8] + dp[6] + dp[4]
dp[16] = dp[12] + dp[8] + dp[6]
..


# 홀수
dp[n] =  dp[n-1]  # n-1 (짝수) 을 만드는 모든 경우에 +1

# 짝수
dp[n] =  dp[n-1]  # n-1 (홀수) 만드는 모든 경우에 +1
       + dp[n//2] # n//2 를 만드는 모든 경우에 x2

'''



import sys

def log(fmt, *args): print(fmt % args, file=sys.stderr)

MOD = 1_000_000_000

def get_input():
    input = sys.stdin.readline
    N = int(input().rstrip())
    return N,

def solve_slow(N:int)->int:
    '''
    일반 dp. O(N logN)
    '''

    dp = [1] * (N+1)
    # dp[j]: j 를 만드는 경우의 수
    # 1 만을 사용하는 경우는 항상 1가지가 존재하므로 초기 값으로 시작.
    # 그런 후, 앞으로 1 사용하는 경우는 빼고 생각.

    tx = 1  # two's exponentiate
    while tx <= N:
        tx = 2*tx  # tx = 2^x, { 2, 4, 8, 16, ..}

        # 모든 ~N 에 대하여 적용. tx 를 하나 추가하는 경우를 카운트.
        for k in range(tx, N+1):
            dp[k] = (dp[k] + dp[k-tx]) % MOD

    return dp[N]


def solve_opt(N:int)->int:
    '''
    2의 멱수 시리즈의 특징을 최대한으로 활용한, O(N) 시간 풀이
    '''
    dp = [0] * (N+1)

    dp[1] = 1 # 초기 값

    for k in range(2, N+1):
        if (k & 1): # 홀수
            dp[k] = dp[k-1]  # n-1 (짝수) 을 만드는 모든 경우에 +1
        else: # 짝수
            dp[k] = (dp[k-1] +    # n-1 (홀수) 만드는 모든 경우에 +1
                     dp[k//2]  # n//2 를 만드는 모든 경우에 x2
                    ) % MOD
    return dp[N]


if __name__ == '__main__':
    # print(solve(*get_input()))
    print(solve_opt(*get_input()))


'''
예제 입력 1
7
예제 출력 1
6
----

run=(python3 a2410.py)

echo '7' | $run
# 6

echo 10 | $run
# 14

echo 100 | $run
# 9828

echo 1000 | $run
# 981471878

echo 10000 | $run
# 573449444

echo 100000 | time $run
# 31071078
# $run  0.12s user 0.01s system 96% cpu 0.132 total

echo 1000000 | time $run
# 59487556
# $run  1.24s user 0.01s system 99% cpu 1.254 total


python3 <<EOF
from a2410 import solve
for i in range(1,11):
    print(i, solve(i))
EOF


'''

