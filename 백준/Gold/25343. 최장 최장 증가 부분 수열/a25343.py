'''
25343번
최장 최장 증가 부분 수열

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
1 초	1024 MB (추가 메모리 없음)	1271	370	294	33.108%

문제
정휘는 정수로 구성된 $N x N$ 크기의 배열의 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸까지 최단 경로로 이동하려고 한다.
한 칸에서 다른 칸으로 이동할 때 서로 변을 공유하는 칸으로만 이동할 수 있다.

정휘는 배열에서 이동하면서 만난 정수들을 순서대로 모아서 성현이에게 선물로 주려고 한다.
성현이는 증가하는 부분 수열의 길이가 긴 수열을 좋아하기 때문에, 정휘는 최장 증가 부분 수열의 길이가 최대인 수열을 만들어서 주려고 한다.

정휘는 문제를 만들어야 하기 때문에 경로를 찾을 여유가 없어서 여러분들에게 도움을 요청했다.
N x N 크기의 배열이 주어지면 만들 수 있는 수열 중 최장 증가 부분 수열의 길이의 최댓값을 대신 구해보자.

입력
첫째 줄에 N이 주어진다. (1 <= N <= 100)

이어 N개의 줄에, 각각 N개의 정수가 공백을 사이에 두고 주어진다.
각 정수는 1 이상 10,000 이하다.

출력
최장 증가 부분 수열의 길이의 최댓값을 출력한다.

----
3:40~

이 문제는 기본 LIS 의 변형이다.
LIS 문제는 일반 dp로 풀 경우 N^2 복잡도를 가진다.

배열 좌상단에서 우하단으로 가는 모든 가능한 경로는 대략 2^N 가지가 있다.
이 각각에 대해서 다시 모두 LIS를 구하려면 N^2 2^N 이라는 말도 안되는 복잡도가 된다.

따라서 경로와 LIS를 한꺼번에 고려하여 문제를 풀어야 한다.
일반 LIS 에서는 1차원 dp 였다면, 이 문제에서는 2차원 dp를 준비한다.

dp[y][x]는 (0,0) 에서 (y,x) 로의 LIS 최대 길이를 저장하도록 한다.

s * * * * * a
          b z
s에서 시작하여 z에 이르는 여러 경로 중, a를 거치는 경로, b를 거치는 경로 둘 만 고려해 보자.
s-a-z 의 LIS 구하는 것과, s-b-z LIS 구하는 식의 앞 부분은 완전히 동일한 작업이다.
(*로 이루어진 경로 부분의 LIS 구하는 로직이 동일함.)

s-a 경로와 s-b 경로의 LIS가 구해졌다고 하자. 그 결과 dp 에도 저장되어 있다.
그럼 이제 s-z 경로의 LIS를 구해야 하는데..

z에 이르는 마지막 경로 길은 a-z, b-z 둘 뿐인데, 이는 모든 지점에 대해서 마찬가지이다.
하지만 s-a, s-b 경로 정보를 결국 확인해야 하는 문제가 있다!

생각해 보니, 중간 경로는 중요하지 않다!
z 보다 더 작은 값을 가진 과거(좌상단 측) 요소 중 lis 최대 값을 찾기만 하면 된다.


'''

import sys

def get_input():
    input = sys.stdin.readline
    N = int(input().rstrip())
    A = []
    for _ in range(N):
        A.append(list(map(int, input().split())))
        assert len(A[-1]) == N
    return N,A


def solve(N:int, A:list[list[int]])->int:
    '''
    Args: A: NxN 크기의 행렬.
    Returns: 가능한 모든 최단 경로의 LIS 값 중 최대 값
    '''

    dp = [ [0]*(N) for _ in range(N) ]
    # dp[y][x]는 (0,0)에서 (y,x)까지의 경로의 LIS 중에서
    # (y,x)에서 종료되는 것의 최장 길이

    dp[0][0] = 1
    maxlislen = 0

    for y in range(0, N):  # y: 1~N-1

        for x in range(0, N):  # x: 1~N-1

            if y==0 and x==0: continue

            # (0,0)에서 (y,x)까지 다시 순회하면서
            # A[y][x]보다 작은 최대 LIS 값을 검색하고
            # 거기에 A[y][x]를 덧붙여서 (+1 해서) LIS를 갱신한다.
            cur = A[y][x]

            dp[y][x] = max(
                (dp[y2][x2]
                for y2 in range(0, y+1)
                for x2 in range(0, x+1)
                if A[y2][x2] < cur),
                default=0
            ) + 1

            maxlislen = max(maxlislen, dp[y][x])

    # dp[][] 전체 중에서 제일 큰 값 선택
    return maxlislen
    # return max(max(j) for j in dp)


if __name__ == '__main__':
    print(solve(*get_input()))



'''
예제 입력 1
3
1 2 3
3 2 1
3 4 5
예제 출력 1
4
첫 번째 예시에서 가능한 방법으로
${1,2,3,1,5), {1,2,2,4,5), {1,3,2,4,5), {1,3,3,4,5)$ 등이 있다.

예제 입력 2
3
1 1 1
1 1 1
1 1 1
예제 출력 2
1
----
run=(python3 a25343.py)

echo '3\n1 2 3\n3 2 1\n3 4 5' | $run
# 4
echo '3\n1 1 1\n1 1 1\n1 1 1' | $run
# 1

'''
