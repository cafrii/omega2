'''
7579번

앱

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
1 초	128 MB	43983	14506	10530	33.720%

문제
우리는 스마트폰을 사용하면서 여러 가지 앱(App)을 실행하게 된다.
대개의 경우 화면에 보이는 ‘실행 중’인 앱은 하나뿐이지만 보이지 않는 상태로 많은 앱이 '활성화'되어 있다.
앱들이 활성화 되어 있다는 것은 화면에 보이지 않더라도 메인 메모리에 직전의 상태가 기록되어 있는 것을 말한다.
현재 실행 중이 아니더라도 이렇게 메모리에 남겨두는 이유는 사용자가 이전에 실행하던 앱을 다시 불러올 때에 직전의 상태를
메인 메모리로부터 읽어 들여 실행 준비를 빠르게 마치기 위해서이다.

하지만 스마트폰의 메모리는 제한적이기 때문에 한번이라도 실행했던 모든 앱을 활성화된 채로 메인 메모리에 남겨두다 보면
메모리 부족 상태가 오기 쉽다. 새로운 앱을 실행시키기 위해 필요한 메모리가 부족해지면 스마트폰의 운영체제는
활성화 되어 있는 앱들 중 몇 개를 선택하여 메모리로부터 삭제하는 수밖에 없다. 이러한 과정을 앱의 ‘비활성화’라고 한다.

메모리 부족 상황에서 활성화 되어 있는 앱들을 무작위로 필요한 메모리만큼 비활성화 하는 것은 좋은 방법이 아니다.
비활성화된 앱들을 재실행할 경우 그만큼 시간이 더 필요하기 때문이다. 여러분은 이러한 앱의 비활성화 문제를
스마트하게 해결하기 위한 프로그램을 작성해야 한다

현재 N개의 앱, A1, ..., AN이 활성화 되어 있다고 가정하자. 이들 앱 Ai는 각각 mi 바이트만큼의 메모리를 사용하고 있다.
또한, 앱 Ai를 비활성화한 후에 다시 실행하고자 할 경우, 추가적으로 들어가는 비용(시간 등)을 수치화 한 것을 ci 라고 하자.
이러한 상황에서 사용자가 새로운 앱 B를 실행하고자 하여, 추가로 M 바이트의 메모리가 필요하다고 하자.
즉, 현재 활성화 되어 있는 앱 A1, ..., AN 중에서 몇 개를 비활성화 하여 M 바이트 이상의 메모리를 추가로 확보해야 하는 것이다.
여러분은 그 중에서 비활성화 했을 경우의 비용 ci의 합을 최소화하여 필요한 메모리 M 바이트를 확보하는 방법을 찾아야 한다.

입력
입력은 3줄로 이루어져 있다.
첫 줄에는 정수 N과 M이 공백문자로 구분되어 주어지며, 둘째 줄과 셋째 줄에는 각각 N개의 정수가 공백문자로 구분되어 주어진다.
둘째 줄의 N개의 정수는 현재 활성화 되어 있는 앱 A1, ..., AN이 사용 중인 메모리의 바이트 수인 m1, ..., mN을 의미하며,
셋째 줄의 정수는 각 앱을 비활성화 했을 경우의 비용 c1, ..., cN을 의미한다

단, 1 ≤ N ≤ 100, 1 ≤ M ≤ 10,000,000이며, 1 ≤ m1, ..., mN ≤ 10,000,000을 만족한다.
또한, 0 ≤ c1, ..., cN ≤ 100이고, M ≤ m1 + m2 + ... + mN이다.

출력
필요한 메모리 M 바이트를 확보하기 위한 앱 비활성화의 최소의 비용을 계산하여 한 줄에 출력해야 한다.

'''

import sys
input = sys.stdin.readline

def log(fmt, *args): print(fmt % args, file=sys.stderr)

# MAX_N = 100
# MAX_ci = 100
MAX_C_SUM = 99999 # (MAX_N*MAX_ci+1)

N, M = map(int,input().split())

mems = list(map(int,input().split()))
costs = list(map(int,input().split()))


'''
    보통의 일반적인 접근 방법:
        dp[index][mem] 2d 배열을 준비하고
        index를 0부터 증가시켜가면서 dp[][] 에 최소 cost 값을 채워감.

    그런데 mem 의 값의 범위가 너무 크기 때문에, dense array로는 메모리 감당이 안된다.
    sparse-array 로 하더라도, mem 경우의 수가 너무 많아지면 결국 현실적이지 않다.

    반대로 cost의 경우는 좀 더 경우의 수가 적다.
    단일 cost는 범위가 0~100 이고, 100개의 요소이면 최대 10000 이므로,
    그냥 모든 가능한 cost 합의 dense array를 사용하는 것도 가능하다.
    좀 더 생각해 보면, cost의 범위가 아닌, cost 조합 case를 관리해야 한다.
    sparse-list 또는 dict 형태의 데이터 구조가 필요하다. 여기서는 dict로..

    cost 중복 경우 처리 예시:
        i0 i1 i2 i3 i4
        m: 30 10 20 35 40
        c: 3  0  3  5  4

        N=5 인 위의 예시에서, c=3에 도달하는 네가지 경우의 수가 존재.
            i0: m=30, c=3
            i2: m=20, c=3
            i0,i1: m=30+10=40, c=3
            i1,i2: m=20+10=30, c=3

        c=3 에 대한 m의 경우의 수는 20, 30, 40 총 세가지.
        이 중에서 최대값인 40을 유지 관리해야 한다.

    주어진 m에 대해서는 최소 비용 c 정보가 필요하고
    주어진 c에 대해서는 최대 메모리 m 정보가 필요하다.

'''

def solve(N:int, M:int, mems:list, costs:list) -> int:
    # cost-to-memory dict.
    # 누적 cost 별 memory 총합 매핑
    c2m:dict = {0:0}

    for i in range(N):
        # 이번에 처리할 항목(item)의 cost 와 memory
        ci,mi = costs[i],mems[i]
        # log('(%d) ---- ci %d, mi %d', i, ci, mi)

        # 기존까지의 모든 costs 조합에 대해서, (ci,mi)를 반영하여 업데이트 한다.
        # 새로운 cost 케이스 이면 그냥 저장하고,
        # 기존 cost 케이스가 있다면 기존 mem 보다 더 큰 경우에만 업데이트 한다.

        # 중간에 dict 가 변경되므로, enumeration 시에 주의 필요.
        # dict 업데이트에 의해 for loop 가 영향을 받으면 안된다.
        # 아래 for 의 reverse 순서가 중요함. 루프 전반부의 c 갱신에 의해 뒷부분의 c2m 값이 변경되어 버리면 안됨.
        # for c in list(c2m.keys()):
        for c in sorted(c2m.keys(), reverse=True):
            m = c2m[c]
            if m >= M: # 추가 관리 불필요.
                continue
            c2m[c+ci] = max(c2m.get(c+ci, 0), m+mi)
        # log('(%d)   %s', i, ' '.join([ f'{k}:{v}' for k,v in sorted(c2m.items()) ]))

    # M 이상의 최소 cost 검색. 정렬된 cost 목록에서 앞에서부터 검사.
    for c,m in sorted(c2m.items()):
        if m >= M:
            # log('===> (%d:%d) min_cost %d', c, m, c)
            return c
    return 99999 # no solution


# cms = list(zip(costs,mems))
# log('%s', cms)

print(solve(N, M, mems, costs))
# print(solve_fast(N, M, mems, costs))



'''
echo '5 60\n30 10 20 35 40\n3 0 3 5 4' | python3 7579.py
-> 6

echo '5 60\n30 10 20 35 60\n3 0 3 5 2' | python3 7579.py
-> 2

4 60
10 5 100 50
1  4 4   2
-> 3

echo '4 60\n10 5 100 50\n1  4 4   2' | python3 7579.py
-> 3

100 100
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
-> 0


5 100
20 20 20 20 20
0 0 0 0 0
-> 0

7 120
20 91 92 93 94 95 100
1 2 2 2 2 2 2
-> 3

24 1
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288 1048576 2097152 4194304 8388608
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
-> 1

19 20169
240 2560 434 6 31 577 500 2715 2916 952 2490 258 1983 1576 3460 933 1660 2804 2584
82 77 81 0 36 6 53 78 49 82 82 33 66 8 60 0 98 91 93
-> 299

echo '19 20169\n240 2560 434 6 31 577 500 2715 2916 952 2490 258 1983 1576 3460 933 1660 2804 2584\n82 77 81 0 36 6 53 78 49 82 82 33 66 8 60 0 98 91 93' | python3 7579.py
-> 484

5 60
30 10 20 35 40
0 1 0 0 0
-> 0

7 120
20 91 92 93 94 95 100
1 2 2 2 2 2 2
-> 3



(python3 <<EOF
import time
from random import seed,randint
seed(time.time())
N = 20
mlist = [ randint(1,100_000) for k in range(N) ]
M = randint(1,sum(mlist))
print(N, M)
print(' '.join([ str(m) for m in mlist ]))
print(' '.join([ str(randint(0,100)) for k in range(N) ]))
EOF
) | time python3 7579.py 2> /dev/null

0.02s user 0.01s system 60% cpu 0.041 total


'''


