'''
큰 수 구성하기

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
1 초	256 MB	9035	2731	2149	30.775%

2025/3/2 제줄 했으나 틀림 판정.
반례는 확보.
아직 적절한 아이디어 찾지 못함.
모든 경우의 수를 다 뒤지는 것이 아닌, 뭔가 더 효율적인 방법이 있을 것 같은데...


문제

N보다 작거나 같은 자연수 중에서, 집합 K의 원소로만 구성된 가장 큰 수를 출력하는 프로그램을 작성하시오.
K의 모든 원소는 1부터 9까지의 자연수로만 구성된다.

예를 들어 N=657이고, K={1, 5, 7}일 때 답은 577이다.

입력
첫째 줄에 N, K의 원소의 개수가 공백을 기준으로 구분되어 자연수로 주어진다.
(10 ≤ N ≤ 100,000,000, 1 ≤ K의 원소의 개수 ≤ 3)
둘째 줄에 K의 원소들이 공백을 기준으로 구분되어 주어진다.
각 원소는 1부터 9까지의 자연수다.

단, 항상 K의 원소로만 구성된 N보다 작거나 같은 자연수를 만들 수 있는 경우만 입력으로 주어진다.

출력
첫째 줄에 N보다 작거나 같은 자연수 중에서, K의 원소로만 구성된 가장 큰 수를 출력한다.
'''

N, K = map(int, input().split())
A = list(map(int, input().split()))

A.sort(reverse=True) # descending order
print(f"**** N:{N}, A:{A}")


def get_max(K, N):
    # K 개의 숫자로 이루어진 수 중 N 보다 작거나 같은 가장 큰 수를 리턴
    print(f"get_max: K:{K}, N:{N}")
    if K == 0:
        return 0
    # if K == 1:
    #     # 한 글자 수의 경우는 직접 계산.
    #     for a in A:
    #         if a <= N:
    #             return a
    #     else:
    #         return -1

    B = get_max(K-1, N//10)
    # K-1 개의 숫자로 이루어진 수 중 N//10 보다 작거나 같은 가장 큰 수를 리턴
    if B == -1:
        return -1

    B = B * 10
    print(f"  B:{B}, A:{A}")
    for i,a in enumerate(A): # A는 내림차순 정렬 된 상태
        if B + a <= N: # 조건에 맞는 첫 번째 수를 찾으면 리턴
            print(f"   max is [{i}], {a} -> B+a = {B+a}")
            return B + a
    else:
        # print("no solution")
        return -1


print(f"---- N:{N}, A:{A}, max:{get_max(K, N)}")
# print(get_max(K, N))







'''
예제 입력 1
657 3
1 5 7

예제 출력 1
577

---------
N=73, K=2, A=[2, 7]
73 2
7 4
47

15 2
9 9
9

100000000 1
1
11111111
'''